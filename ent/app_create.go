// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/fitzix/assassin/ent/app"
	"github.com/fitzix/assassin/ent/carousel"
	"github.com/fitzix/assassin/ent/category"
	"github.com/fitzix/assassin/ent/hot"
	"github.com/fitzix/assassin/ent/tag"
	"github.com/fitzix/assassin/ent/version"
)

// AppCreate is the builder for creating a App entity.
type AppCreate struct {
	config
	created_at *time.Time
	updated_at *time.Time
	deleted_at *time.Time
	name       *string
	_type      *app.Type
	icon       *string
	title      *string
	status     *app.Status
	tags       map[int]struct{}
	categories map[int]struct{}
	carousels  map[int]struct{}
	versions   map[int]struct{}
	hot        map[int]struct{}
}

// SetCreatedAt sets the created_at field.
func (ac *AppCreate) SetCreatedAt(t time.Time) *AppCreate {
	ac.created_at = &t
	return ac
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (ac *AppCreate) SetNillableCreatedAt(t *time.Time) *AppCreate {
	if t != nil {
		ac.SetCreatedAt(*t)
	}
	return ac
}

// SetUpdatedAt sets the updated_at field.
func (ac *AppCreate) SetUpdatedAt(t time.Time) *AppCreate {
	ac.updated_at = &t
	return ac
}

// SetNillableUpdatedAt sets the updated_at field if the given value is not nil.
func (ac *AppCreate) SetNillableUpdatedAt(t *time.Time) *AppCreate {
	if t != nil {
		ac.SetUpdatedAt(*t)
	}
	return ac
}

// SetDeletedAt sets the deleted_at field.
func (ac *AppCreate) SetDeletedAt(t time.Time) *AppCreate {
	ac.deleted_at = &t
	return ac
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (ac *AppCreate) SetNillableDeletedAt(t *time.Time) *AppCreate {
	if t != nil {
		ac.SetDeletedAt(*t)
	}
	return ac
}

// SetName sets the name field.
func (ac *AppCreate) SetName(s string) *AppCreate {
	ac.name = &s
	return ac
}

// SetType sets the type field.
func (ac *AppCreate) SetType(a app.Type) *AppCreate {
	ac._type = &a
	return ac
}

// SetNillableType sets the type field if the given value is not nil.
func (ac *AppCreate) SetNillableType(a *app.Type) *AppCreate {
	if a != nil {
		ac.SetType(*a)
	}
	return ac
}

// SetIcon sets the icon field.
func (ac *AppCreate) SetIcon(s string) *AppCreate {
	ac.icon = &s
	return ac
}

// SetTitle sets the title field.
func (ac *AppCreate) SetTitle(s string) *AppCreate {
	ac.title = &s
	return ac
}

// SetNillableTitle sets the title field if the given value is not nil.
func (ac *AppCreate) SetNillableTitle(s *string) *AppCreate {
	if s != nil {
		ac.SetTitle(*s)
	}
	return ac
}

// SetStatus sets the status field.
func (ac *AppCreate) SetStatus(a app.Status) *AppCreate {
	ac.status = &a
	return ac
}

// SetNillableStatus sets the status field if the given value is not nil.
func (ac *AppCreate) SetNillableStatus(a *app.Status) *AppCreate {
	if a != nil {
		ac.SetStatus(*a)
	}
	return ac
}

// AddTagIDs adds the tags edge to Tag by ids.
func (ac *AppCreate) AddTagIDs(ids ...int) *AppCreate {
	if ac.tags == nil {
		ac.tags = make(map[int]struct{})
	}
	for i := range ids {
		ac.tags[ids[i]] = struct{}{}
	}
	return ac
}

// AddTags adds the tags edges to Tag.
func (ac *AppCreate) AddTags(t ...*Tag) *AppCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ac.AddTagIDs(ids...)
}

// AddCategoryIDs adds the categories edge to Category by ids.
func (ac *AppCreate) AddCategoryIDs(ids ...int) *AppCreate {
	if ac.categories == nil {
		ac.categories = make(map[int]struct{})
	}
	for i := range ids {
		ac.categories[ids[i]] = struct{}{}
	}
	return ac
}

// AddCategories adds the categories edges to Category.
func (ac *AppCreate) AddCategories(c ...*Category) *AppCreate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return ac.AddCategoryIDs(ids...)
}

// AddCarouselIDs adds the carousels edge to Carousel by ids.
func (ac *AppCreate) AddCarouselIDs(ids ...int) *AppCreate {
	if ac.carousels == nil {
		ac.carousels = make(map[int]struct{})
	}
	for i := range ids {
		ac.carousels[ids[i]] = struct{}{}
	}
	return ac
}

// AddCarousels adds the carousels edges to Carousel.
func (ac *AppCreate) AddCarousels(c ...*Carousel) *AppCreate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return ac.AddCarouselIDs(ids...)
}

// AddVersionIDs adds the versions edge to Version by ids.
func (ac *AppCreate) AddVersionIDs(ids ...int) *AppCreate {
	if ac.versions == nil {
		ac.versions = make(map[int]struct{})
	}
	for i := range ids {
		ac.versions[ids[i]] = struct{}{}
	}
	return ac
}

// AddVersions adds the versions edges to Version.
func (ac *AppCreate) AddVersions(v ...*Version) *AppCreate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return ac.AddVersionIDs(ids...)
}

// SetHotID sets the hot edge to Hot by id.
func (ac *AppCreate) SetHotID(id int) *AppCreate {
	if ac.hot == nil {
		ac.hot = make(map[int]struct{})
	}
	ac.hot[id] = struct{}{}
	return ac
}

// SetNillableHotID sets the hot edge to Hot by id if the given value is not nil.
func (ac *AppCreate) SetNillableHotID(id *int) *AppCreate {
	if id != nil {
		ac = ac.SetHotID(*id)
	}
	return ac
}

// SetHot sets the hot edge to Hot.
func (ac *AppCreate) SetHot(h *Hot) *AppCreate {
	return ac.SetHotID(h.ID)
}

// Save creates the App in the database.
func (ac *AppCreate) Save(ctx context.Context) (*App, error) {
	if ac.created_at == nil {
		v := app.DefaultCreatedAt()
		ac.created_at = &v
	}
	if ac.updated_at == nil {
		v := app.DefaultUpdatedAt()
		ac.updated_at = &v
	}
	if ac.name == nil {
		return nil, errors.New("ent: missing required field \"name\"")
	}
	if err := app.NameValidator(*ac.name); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"name\": %v", err)
	}
	if ac._type == nil {
		v := app.DefaultType
		ac._type = &v
	}
	if err := app.TypeValidator(*ac._type); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"type\": %v", err)
	}
	if ac.icon == nil {
		return nil, errors.New("ent: missing required field \"icon\"")
	}
	if err := app.IconValidator(*ac.icon); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"icon\": %v", err)
	}
	if ac.title != nil {
		if err := app.TitleValidator(*ac.title); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"title\": %v", err)
		}
	}
	if ac.status == nil {
		v := app.DefaultStatus
		ac.status = &v
	}
	if err := app.StatusValidator(*ac.status); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"status\": %v", err)
	}
	if len(ac.hot) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"hot\"")
	}
	return ac.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (ac *AppCreate) SaveX(ctx context.Context) *App {
	v, err := ac.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (ac *AppCreate) sqlSave(ctx context.Context) (*App, error) {
	var (
		a     = &App{config: ac.config}
		_spec = &sqlgraph.CreateSpec{
			Table: app.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: app.FieldID,
			},
		}
	)
	if value := ac.created_at; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: app.FieldCreatedAt,
		})
		a.CreatedAt = *value
	}
	if value := ac.updated_at; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: app.FieldUpdatedAt,
		})
		a.UpdatedAt = *value
	}
	if value := ac.deleted_at; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: app.FieldDeletedAt,
		})
		a.DeletedAt = *value
	}
	if value := ac.name; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: app.FieldName,
		})
		a.Name = *value
	}
	if value := ac._type; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  *value,
			Column: app.FieldType,
		})
		a.Type = *value
	}
	if value := ac.icon; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: app.FieldIcon,
		})
		a.Icon = *value
	}
	if value := ac.title; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: app.FieldTitle,
		})
		a.Title = *value
	}
	if value := ac.status; value != nil {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  *value,
			Column: app.FieldStatus,
		})
		a.Status = *value
	}
	if nodes := ac.tags; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   app.TagsTable,
			Columns: app.TagsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tag.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ac.categories; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   app.CategoriesTable,
			Columns: app.CategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: category.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ac.carousels; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   app.CarouselsTable,
			Columns: []string{app.CarouselsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: carousel.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ac.versions; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   app.VersionsTable,
			Columns: []string{app.VersionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: version.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ac.hot; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   app.HotTable,
			Columns: []string{app.HotColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hot.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if err := sqlgraph.CreateNode(ctx, ac.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	a.ID = int(id)
	return a, nil
}
